package ru.domrfbank.evklid.service.document;

import static org.apache.tomcat.util.http.fileupload.FileUploadBase.ATTACHMENT;
import static ru.domrfbank.evklid.exception.Error.EDK_F_001;
import static ru.domrfbank.evklid.exception.Error.EDK_F_002;
import static ru.domrfbank.evklid.exception.Error.EDK_F_003;
import static ru.domrfbank.evklid.util.CommonUtil.numberIsNull;
import static ru.domrfbank.evklid.util.DictionaryUtil.isOtherDossier;

import jakarta.servlet.ServletOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.sf.jasperreports.engine.JREmptyDataSource;
import net.sf.jasperreports.engine.JRException;
import net.sf.jasperreports.engine.JasperCompileManager;
import net.sf.jasperreports.engine.JasperExportManager;
import net.sf.jasperreports.engine.JasperFillManager;
import net.sf.jasperreports.engine.JasperPrint;
import net.sf.jasperreports.engine.JasperReport;
import net.sf.jasperreports.engine.data.JRBeanCollectionDataSource;
import org.apache.commons.io.FilenameUtils;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.InputStreamResource;
import org.springframework.core.io.Resource;
import org.springframework.http.ContentDisposition;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StreamUtils;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.mvc.method.annotation.StreamingResponseBody;
import ru.domrfbank.evklid.client.integration.clients.ClientsClient;
import ru.domrfbank.evklid.client.integration.clients.dto.PersonClientGetResponse;
import ru.domrfbank.evklid.config.LoggerRequestContext;
import ru.domrfbank.evklid.config.validator.MimeTypeValidator;
import ru.domrfbank.evklid.dto.document.CreateDocumentRequestDto;
import ru.domrfbank.evklid.dto.document.CreateDocumentResponseDto;
import ru.domrfbank.evklid.dto.document.CreateDocumentResponseDto.FileInfo;
import ru.domrfbank.evklid.dto.document.CreateNewDocumentVersionResponseDto;
import ru.domrfbank.evklid.dto.document.DocumentDto;
import ru.domrfbank.evklid.dto.document.DocumentVersionDto;
import ru.domrfbank.evklid.dto.document.DownloadArchiveRequestDto;
import ru.domrfbank.evklid.dto.document.FileModelDto;
import ru.domrfbank.evklid.dto.document.GetAllDocumentVersionsResponseDto;
import ru.domrfbank.evklid.dto.document.GetSignatureResponseDto;
import ru.domrfbank.evklid.dto.document.ProductDto;
import ru.domrfbank.evklid.dto.document.RegisterReportDto;
import ru.domrfbank.evklid.dto.document.UpdateDocumentRequestDto;
import ru.domrfbank.evklid.dto.document.VersionDto;
import ru.domrfbank.evklid.dto.dossier.DossierDto;
import ru.domrfbank.evklid.enumeration.AuditEventType;
import ru.domrfbank.evklid.exception.CoreException;
import ru.domrfbank.evklid.model.Client;
import ru.domrfbank.evklid.model.Document;
import ru.domrfbank.evklid.model.DocumentType;
import ru.domrfbank.evklid.model.DocumentVersion;
import ru.domrfbank.evklid.model.Dossier;
import ru.domrfbank.evklid.model.FileEntity;
import ru.domrfbank.evklid.model.Office;
import ru.domrfbank.evklid.model.Signature;
import ru.domrfbank.evklid.repository.ClientRepository;
import ru.domrfbank.evklid.repository.DocumentRepository;
import ru.domrfbank.evklid.repository.DocumentVersionRepository;
import ru.domrfbank.evklid.repository.FileRepository;
import ru.domrfbank.evklid.repository.SignatureRepository;
import ru.domrfbank.evklid.service.audit.AuditService;
import ru.domrfbank.evklid.service.dictionary.DictionaryService;
import ru.domrfbank.evklid.service.dossier.DossierService;
import ru.domrfbank.evklid.service.file.FileUtilService;
import ru.domrfbank.evklid.service.integration.SignatureInfoExtractor;
import ru.domrfbank.evklid.service.sevice.UserService;
import ru.domrfbank.evklid.service.storage.DocstoreService;

@Service
@RequiredArgsConstructor
@Slf4j
public class DocumentServiceImpl {

    private static final String REPORT_FILE_NAME = "register.pdf";
    private static final String DEFAULT_SOURCE_SYSTEM = "999";
    private final DocumentRepository documentRepository;
    private final DocstoreService docstoreService;
    private final LoggerRequestContext loggerRequestContext;
    private final ClientRepository clientRepository;
    private final ClientsClient clients;
    private final DocumentVersionService documentVersionService;
    private final DictionaryService dictionaryService;
    private final DossierService dossierService;
    private final DocumentReuseService documentReuseService;
    private final AuditService auditService;
    private final UserService userService;
    private final FileRepository fileRepository;
    private final SignatureInfoExtractor signatureInfoExtractor;
    private final SignatureRepository signatureRepository;
    private final DocumentVersionRepository documentVersionRepository;
    private final MimeTypeValidator mimeTypeValidator;
    private final FileUtilService fileUtilService;
    private final FileSignatureService fileSignatureService;

    public StreamingResponseBody downloadFile(UUID documentId, ServletOutputStream out) {
        DocumentVersion lastVersion = documentVersionService.getLastVersionByDocumentId(documentId);
        userService.checkPermission(lastVersion);
        List<File> files = fileUtilService.downloadFilesFromDocstore(lastVersion);

        return fileUtilService.getZip(files, out);
    }

    public StreamingResponseBody downloadFileByVersionId(UUID versionId, ServletOutputStream out) {
        DocumentVersion documentVersion = documentVersionService.getByVersionId(versionId);
        userService.checkPermission(documentVersion);
        List<File> files = fileUtilService.downloadFilesFromDocstore(documentVersion);

        return fileUtilService.getZip(files, out);
    }

    public GetAllDocumentVersionsResponseDto getAllDocumentVersions(UUID documentId) {
        Document document = get(documentId);
        userService.checkPermission(document);
        List<DocumentVersion> documentVersions = documentVersionService.getVersionsByDocument(document);
        List<DocumentVersionDto> versions = new ArrayList<>();

        for (DocumentVersion dv : documentVersions) {
            List<FileModelDto> fileModelDtoList = dv.getFiles().stream()
                .map(file -> FileModelDto.builder()
                    .fileExtension(file.getFileExtension())
                    .fileName(file.getFilename())
                    .fileSize(file.getContentSize())
                    .build())
                .toList();

            versions.add(DocumentVersionDto.builder()
                .versionId(dv.getVersionId())
                .author(dv.getAuthor())
                .createdAt(dv.getCreatedAt())
                .files(fileModelDtoList)
                .build());
        }

        return GetAllDocumentVersionsResponseDto.builder()
                .documentId(document.getDocumentId())
                .documentTypeId(document.getDocumentType().getId())
                .documentGroupId(document.getDocumentType().getDocumentGroup().getId())
                .author(document.getAuthor())
                .officeId(document.getOffice().getId())
                .createdAt(document.getCreatedAt())
                .expirationDate(document.getExpirationDate())
                .versions(versions)
                .build();
    }

    @Transactional
    public void updateDocument(UUID documentId, UpdateDocumentRequestDto requestDto) {
        Document document = get(documentId);
        userService.checkPermission(document.getDossier().getClient());
        Dossier dossier = dossierService.get(requestDto.getDossierId());
        userService.checkPermission(dossier.getClient());
        DocumentType documentType = dictionaryService.getDocumentType(requestDto.getDocumentTypeId());
        Office office = dictionaryService.getOfficeBy(requestDto.getOfficeId());
        document.setDossier(dossier);
        document.setDocumentType(documentType);
        document.setOffice(office);
        document.setExpirationDate(requestDto.getExpirationDate());
        documentRepository.save(document);
    }

    @Transactional
    public CreateNewDocumentVersionResponseDto createNewDocumentVersion(UUID documentId, List<MultipartFile> files) {
        Document document = get(documentId);
        userService.checkPermission(document.getDossier().getClient());
        DocumentVersion documentVersion =  documentVersionService.create(document);
        Map<MultipartFile, List<MultipartFile>> filesMap = fileSignatureService.mapFilesToSignatures(files);
        List<MultipartFile> docList = fileSignatureService.getFilesList(filesMap);
        List<FileEntity> filesList = getFilesList(docList, documentVersion,
            docList.stream().map(doc -> FilenameUtils.getExtension(doc.getOriginalFilename())).toList());
        filesList = fileRepository.saveAll(filesList);
        documentVersion.setFiles(filesList);
        documentVersionRepository.save(documentVersion);
        saveSignatures(filesMap, filesList);

        return CreateNewDocumentVersionResponseDto.builder()
                .clientId(document.getDossier().getClient().getId())
                .absClientId(document.getDossier().getClient().getAbsClientId())
                .dossierDto(DossierDto.builder()
                        .dossierId(document.getDossier().getId())
                        .dossierTypeId(document.getDossier().getDossierType().getId())
                        .dossierTypeName(document.getDossier().getDossierType().getName())
                        .productDto(ProductDto.create(document.getDossier()))
                        .build())
                .documentDto(DocumentDto.builder()
                        .documentId(document.getDocumentId())
                        .versions(Collections.singletonList(VersionDto.create(documentVersion)))
                        .documentTypeName(document.getDocumentType().getName())
                        .documentGroupId(document.getDocumentType().getDocumentGroup().getId())
                        .documentGroupName(document.getDocumentType().getDocumentGroup().getName())
                        .author(documentVersion.getAuthor())
                        .officeId(document.getOffice().getId())
                        .officeName(document.getOffice().getLabel())
                        .createdAt(documentVersion.getCreatedAt())
                        .expirationDate(document.getExpirationDate())
                        .build())
                .build();
    }

    @Transactional
    public CreateDocumentResponseDto create(CreateDocumentRequestDto requestDto, List<MultipartFile> files) {
        DocumentType documentType = dictionaryService.getDocumentType(requestDto.getDocumentTypeId());
        Dossier dossier = dossierService.get(requestDto.getDossierId());
        userService.checkPermission(dossier.getClient());

        Office office = dictionaryService.getOfficeBy(requestDto.getOfficeId());
        Document document;
        if (isOtherDossier(dossier)) {
            document = create(dossier, documentType, office);
        } else {
            document = getOrCreate(dossier, documentType, office);
        }
        if (!numberIsNull(requestDto.getStoragePeriod())) {
            document.setExpirationDate(document.getCreatedAt().plusYears(requestDto.getStoragePeriod()));
        }

        DocumentVersion documentVersion = documentVersionService.create(document);

        Map<MultipartFile, List<MultipartFile>> filesMap = fileSignatureService.mapFilesToSignatures(files);
        List<MultipartFile> docList = fileSignatureService.getFilesList(filesMap);
        List<FileEntity> filesList = getFilesList(docList, documentVersion,
            docList.stream().map(doc -> FilenameUtils.getExtension(doc.getOriginalFilename())).toList());
        filesList = fileRepository.saveAll(filesList);
        documentVersion.setFiles(filesList);
        documentVersionRepository.save(documentVersion);
        saveSignatures(filesMap, filesList);
        List<FileInfo> fileInfos = CreateDocumentResponseDto.createFileInfo(documentVersion, requestDto);

        return CreateDocumentResponseDto.builder()
            .clientId(documentVersion.getDocument().getDossier().getClient().getId())
            .absClientId(documentVersion.getDocument().getDossier().getClient().getAbsClientId())
            .dossierId(dossier.getId())
            .documentId(document.getDocumentId())
            .versionId(documentVersion.getVersionId())
            .versionNumber(documentVersion.getVersionNumber())
            .files(fileInfos)
            .build();
    }

    public Document getOrCreate(Dossier dossier, DocumentType documentType, Office office){
        return documentRepository.findByDossierAndDocumentType(dossier, documentType)
                .orElseGet(() -> create(dossier, documentType, office));
    }

    public Document create(Dossier dossier, DocumentType documentType, Office office) {
        return create(dossier, documentType, office, loggerRequestContext.getConsumer());
    }

    public Document create(Dossier dossier, DocumentType documentType, Office office, String author) {
        return documentRepository.save(Document.builder()
            .dossier(dossier)
            .documentType(documentType)
            .documentId(UUID.randomUUID())
            .author(author)
            .isDeleted(false)
            .office(office)
            .createdAt(LocalDateTime.now())
            .expirationDate(LocalDateTime.now().plusYears(documentType.getStoragePeriod()))
            .build());
    }

    public Document get(UUID id){
        return documentRepository.findByDocumentId(id)
                .orElseThrow(() -> new CoreException(EDK_F_002, id));
    }

    public StreamingResponseBody getArchive(DownloadArchiveRequestDto downloadArchiveRequestDto, ServletOutputStream out) {
        List<Client> uniqueClients = clientRepository.findUniqueClientsByDocumentIds(downloadArchiveRequestDto.getDocuments());
        if (uniqueClients.size() > 1)
            throw new CoreException(EDK_F_003);
        userService.checkPermission(uniqueClients.get(0));
        var documentList = documentRepository.findByDocumentIdIn(downloadArchiveRequestDto.getDocuments());
        List<DocumentVersion> documentVersions = documentVersionService.getLastVersionsByDocumentIds(downloadArchiveRequestDto.getDocuments());
        Map<DocumentType, List<UUID>> filesByType = new HashMap<>();

        for (DocumentVersion dv : documentVersions) {
            DocumentType docType = dv.getDocument().getDocumentType();
            filesByType.computeIfAbsent(docType, k -> new ArrayList<>())
                .addAll(dv.getFiles().stream().map(FileEntity::getContentId).toList());
        }

        auditService.save(AuditEventType.DOWNLOAD_ZIP_DOCUMENT, documentList.stream()
            .map(e -> e.getDossier().getId().toString())
            .distinct()
            .collect(Collectors.joining(", "))
        );

        return getZip(out, filesByType, downloadArchiveRequestDto, documentVersions, uniqueClients);
    }

    public GetSignatureResponseDto getSignature(UUID sigUUID) {
        Signature signature = signatureRepository.findBySignatureFileId(sigUUID)
            .orElseThrow(() -> new CoreException(EDK_F_002, sigUUID));
        userService.checkPermission(signature);

        return GetSignatureResponseDto.builder()
            .certificateEndDate(signature.getCertificateEndDate())
            .certificateIssued(signature.getCertificateIssued())
            .certificateNumber(signature.getCertificateNumber())
            .certificateStartDate(signature.getCertificateStartDate())
            .documentTypeName(signature.getFile().getDocumentVersion().getDocument().getDocumentType().getName())
            .extSigFileId(signature.getExtSignatureFileId())
            .fileId(signature.getFile().getContentId())
            .fileName(signature.getFile().getFilename())
            .signatureFileId(signature.getSignatureFileId())
            .signatureVerif(signature.getSignatureVerif())
            .signDate(signature.getSignDate())
            .signer(signature.getSigner())
            .build();
    }

    public ResponseEntity<Resource> downloadDocumentFile(UUID fileUUID) {
        FileEntity dbFile = fileRepository.findByContentId(fileUUID)
            .orElseThrow(() -> new CoreException(EDK_F_002, fileUUID.toString()));
        userService.checkPermission(dbFile);
        File file = docstoreService.downloadFile(fileUUID);
        InputStreamResource resource;
        HttpHeaders headers = new HttpHeaders();
        try {
            resource = new InputStreamResource(new FileInputStream(file));
            String contentType = Files.probeContentType(file.toPath());
            if (contentType == null) {
                contentType = mimeTypeValidator.getMimeType(file.getName());
            }
            ContentDisposition disposition = ContentDisposition.builder(ATTACHMENT)
                .filename(file.getName(), StandardCharsets.UTF_8).build();

            headers.setContentType(MediaType.parseMediaType(contentType));
            headers.setContentLength(file.length());
            headers.setContentDisposition(disposition);
        } catch (IOException e) {
            throw new CoreException(EDK_F_001, e.getMessage());
        }
        file.delete();
        return new ResponseEntity<>(resource, headers, HttpStatus.OK);
    }

    private List<RegisterReportDto> getReportDataSource(List<DocumentVersion> documentVersions){
        List<RegisterReportDto> dataSource = new ArrayList<>();
        AtomicInteger index = new AtomicInteger(1);
        for(DocumentVersion documentVersion : documentVersions) {
            DocumentType documentType = documentVersion.getDocument().getDocumentType();
            documentVersion.getFiles().forEach(f -> dataSource.add(RegisterReportDto.builder()
                .number(index.getAndIncrement())
                .type(documentType.getName())
                .name(f.getFilename())
                .storagePeriod(String.valueOf(documentType.getStoragePeriod()))
                .group(documentType.getDocumentGroup().getName())
                .createdDate(documentVersion.getCreatedAt())
                .build()));
        }
        return dataSource;
    }

    private File createRegisterReport(List<RegisterReportDto> dataSource, Client client) throws JRException, IOException {
        ClassPathResource classPathResource = new ClassPathResource("report/register.jrxml");
        JasperReport jasperReport = JasperCompileManager.compileReport(classPathResource.getInputStream());
        JRBeanCollectionDataSource jrBeanCollectionDataSource = new JRBeanCollectionDataSource(dataSource);
        PersonClientGetResponse personClientGetResponse = clients.getClientPerson(String.valueOf(client.getAbsClientId()));
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("client", personClientGetResponse.getFullName());
        parameters.put("count", dataSource.size());
        parameters.put("collectionDataSource", jrBeanCollectionDataSource);
        JasperPrint jasperPrint =  JasperFillManager.fillReport(jasperReport, parameters, new JREmptyDataSource());
        File report = new File(System.getProperty("java.io.tmpdir") + File.separator + REPORT_FILE_NAME);
        try (FileOutputStream fos = new FileOutputStream(report)) {
            JasperExportManager.exportReportToPdfStream(jasperPrint, fos);
        }
        return report;
    }

    public Document getOrNull(Dossier dossier, DocumentType documentType) {
        var document = documentRepository.findByDossierAndDocumentType(dossier, documentType).orElse(null);
        if (Objects.isNull(document)) {
            var documentReuse = documentReuseService.getOrNull(dossier, documentType);
            document = documentReuse != null ? documentReuse.getDocument() : null;
        }
        return document;
    }

    private String removeSpecialCharacters(String filename) {
        return filename.replaceAll("[\\\\/:*?\"<>|]","_");
    }

    private List<FileEntity> getFilesList(List<MultipartFile> docList, DocumentVersion documentVersion,
        List<String> fileExtensionList) {

        List<FileEntity> filesList = new ArrayList<>();
        for (int i = 0; i < docList.size(); i++) {
            MultipartFile doc = docList.get(i);
            UUID contentId = docstoreService.upload(doc);
            filesList.add(makeFile(documentVersion, contentId, fileExtensionList.get(i), doc));
        }
        return filesList;
    }

    private FileEntity makeFile(DocumentVersion documentVersion, UUID contentId,
        String fileExtension, MultipartFile doc) {

        return FileEntity.builder()
            .documentVersion(documentVersion)
            .contentId(contentId)
            .author(loggerRequestContext.getConsumer())
            .contentSize(doc.getSize())
            .filename(FilenameUtils.getBaseName(doc.getOriginalFilename()))
            .fileExtension(fileExtension)
            .sourceSystem(DEFAULT_SOURCE_SYSTEM)
            .build();
    }

    private void saveSignatures(Map<MultipartFile, List<MultipartFile>> filesMap, List<FileEntity> filesList) {
        for (int i = 0; i < filesList.size(); i++) {
            FileEntity file = filesList.get(i);
            MultipartFile doc = fileSignatureService.getDocByFilename(filesMap,
                file.getFilename() + "."  + file.getFileExtension());

            List<MultipartFile> fileSigList = fileSignatureService.getSignaturesByFilename(filesMap,
                file.getFilename() + "."  + file.getFileExtension());
            List<Signature> signatureList = new ArrayList<>();

            for (MultipartFile sigFile : fileSigList) {
                List<Signature> signatures = signatureInfoExtractor.getSignatureInfo(sigFile, doc);
                UUID signatureFileId = docstoreService.upload(sigFile);
                signatures.forEach(signature -> {
                    signature.setFile(file);
                    signature.setSignatureFileId(signatureFileId);
                });
                signatureList.addAll(signatures);
            }
            signatureList = signatureRepository.saveAll(signatureList);
            file.setSignatures(signatureList);
        }
        fileRepository.saveAll(filesList);
    }

    private StreamingResponseBody getZip(ServletOutputStream out, Map<DocumentType, List<UUID>> filesByType,
        DownloadArchiveRequestDto downloadArchiveRequestDto, List<DocumentVersion> documentVersions, List<Client> uniqueClients) {
        return outputStreamResponse -> {
            try (ZipOutputStream zipOut = new ZipOutputStream(out)) {
                // Загружаем и добавляем файлы в архив по типу документа
                for (Map.Entry<DocumentType, List<UUID>> entry : filesByType.entrySet()) {
                    DocumentType docType = entry.getKey();
                    List<UUID> fileIds = entry.getValue();
                    // Загрузка файлов для каждого типа документа
                    File zipFile = docstoreService.downloadFilesZip(fileIds);
                    try (FileInputStream fileInputStream = new FileInputStream(zipFile);
                        ZipInputStream zipIn = new ZipInputStream(fileInputStream)) {
                        ZipEntry zipEntry;
                        while ((zipEntry = zipIn.getNextEntry()) != null) {
                            // Путь в новом архиве - создаем папку по типу документа
                            String newEntryName = docType.getName() + "/" + zipEntry.getName();
                            zipOut.putNextEntry(new ZipEntry(newEntryName));
                            // Копируем содержимое файла в новый архив
                            byte[] buffer = new byte[1024];
                            int length;
                            while ((length = zipIn.read(buffer)) > 0) {
                                zipOut.write(buffer, 0, length);
                            }
                            zipOut.closeEntry();
                            zipIn.closeEntry();
                        }
                    } catch (IOException e) {
                        throw new RuntimeException("Error processing zip entry for document type: " + docType.getName(), e);
                    } finally {
                        zipFile.delete();
                    }
                }
                if (downloadArchiveRequestDto.getOptions() != null && downloadArchiveRequestDto.getOptions().isRegister()) {
                    File report = createRegisterReport(getReportDataSource(documentVersions), uniqueClients.get(0));
                    zipOut.putNextEntry(new ZipEntry(report.getName()));
                    var fis = new FileInputStream(report);
                    StreamUtils.copy(fis, zipOut);
                    fis.close();
                    report.delete();
                }
            } catch (IOException | JRException e) {
                throw new RuntimeException(e);
            }
        };
    }

}


package ru.domrfbank.evklid.dto.document;

import com.fasterxml.jackson.annotation.JsonProperty;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.ToString;
import ru.domrfbank.evklid.model.DocumentVersion;
import ru.domrfbank.evklid.model.FileEntity;

@Data
@AllArgsConstructor
@Builder
@ToString
@Schema(description = "Ответ на загрузку файла в существующее досье", name = "CreateDocumentResponseDtoV2")
public class CreateDocumentResponseDto {

    @JsonProperty("clientId")
    private Long clientId;

    @JsonProperty("absClientId")
    private Long absClientId;

    @JsonProperty("dossierId")
    private Long dossierId;

    @JsonProperty("documentId")
    private UUID documentId;

    @JsonProperty("versionId")
    private UUID versionId;

    @JsonProperty("versionNumber")
    private Long versionNumber;

    @JsonProperty("files")
    private List<FileInfo> files;

    @Data
    @AllArgsConstructor
    @Builder
    @ToString
    public static class FileInfo {

        @JsonProperty("fileId")
        private UUID fileId;

        @JsonProperty("fileName")
        private String fileName;

        @JsonProperty("signatures")
        private List<Signature> signatures;
    }

    @Data
    @AllArgsConstructor
    @Builder
    @ToString
    public static class Signature {

        @JsonProperty("sigFileName")
        private String sigFileName;

        @JsonProperty("sigFileId")
        private UUID sigFileId;
    }

    public static List<FileInfo> createFileInfo(DocumentVersion dv, CreateDocumentRequestDto req) {
        List<FileInfo> fileInfos = new ArrayList<>();
        List<FileEntity> fileList = dv.getFiles();

        for (int i = 0; i < fileList.size(); i++) {
            FileEntity file = fileList.get(i);
            List<Signature> signatures = new ArrayList<>();
            for (int j = 0; j < file.getSignatures().size(); j++) {
                signatures.add(Signature.builder()
                    .sigFileId(file.getSignatures().get(j).getSignatureFileId())
                    //todo: did надо что-то придумать, теперь нет такаой связи
                    .sigFileName(req.getFiles().get(i).getSignatures().get(j).getSigFileName())
                    .build());
            }
            fileInfos.add(FileInfo.builder()
                .fileId(file.getContentId())
                .fileName(file.getFilename())
                .signatures(signatures)
                .build());
        }

        return fileInfos;
    }

}
