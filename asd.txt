import org.apache.camel.CamelContext;
import org.apache.camel.EndpointInject;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.AdviceWith;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.test.spring.junit5.CamelSpringBootTest;
import org.apache.camel.test.spring.junit5.MockEndpoints;
import org.apache.camel.test.spring.junit5.UseAdviceWith;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ActiveProfiles;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.when;

@SpringBootTest
@CamelSpringBootTest
@UseAdviceWith
@ActiveProfiles("test")
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
@MockEndpoints("https:*")
public class CamelRoutesTest {

    @Autowired
    private CamelContext camelContext;

    @Autowired
    private ProducerTemplate producerTemplate;

    @MockBean
    private AuthService authService;

    @BeforeEach
    public void setup() throws Exception {
        // Мокируем AuthService перед запуском контекста
        when(authService.getToken()).thenReturn("mocked-token");
        
        // Не запускаем контекст здесь! Будет запущен после AdviceWith
    }

    @AfterEach
    public void tearDown() throws Exception {
        // Очищаем контекст после каждого теста
        camelContext.stop();
    }

    @Test
    public void testCreatePackageRoute_Success() throws Exception {
        // 1. Настройка AdviceWith
        AdviceWith.adviceWith(camelContext, "direct:ru.seventech.esb.technoprom.createPackage.v2", a -> {
            a.weaveByToUri("https:*").replace().to("mock:https:external-service/createPackage");
        });

        // 2. Явный запуск контекста ПОСЛЕ настройки AdviceWith
        camelContext.start();

        // 3. Получение mock endpoint
        MockEndpoint mockCreatePackage = camelContext.getEndpoint(
            "mock:https:external-service/createPackage", MockEndpoint.class);
        
        mockCreatePackage.expectedMessageCount(1);
        mockCreatePackage.whenAnyExchangeReceived(exchange -> {
            exchange.getMessage().setBody("{\"id\":\"12345\"}");
            exchange.getMessage().setHeader(Exchange.HTTP_RESPONSE_CODE, 200);
        });

        // 4. Выполнение теста
        String requestBody = "{\"packageType\":\"TYPE\",\"packageData\":{},\"orgId\":\"ORG1\",\"agentId\":\"AGENT1\"}";
        String response = producerTemplate.requestBody(
            "direct:ru.seventech.esb.technoprom.createPackage.v2", 
            requestBody,
            String.class
        );

        // 5. Проверки
        mockCreatePackage.assertIsSatisfied();
        assertEquals("{\"id\":\"12345\"}", response);
    }

    @Test
    public void testGetDocumentRoute_Success() throws Exception {
        // Настройка AdviceWith
        AdviceWith.adviceWith(camelContext, "direct:getDocumentRoute", a -> {
            a.weaveByToUri("https:*").replace().to("mock:https:external-service/getDocument");
        });

        // Явный запуск контекста
        camelContext.start();

        MockEndpoint mockGetDocument = camelContext.getEndpoint(
            "mock:https:external-service/getDocument", MockEndpoint.class);
        
        // Настройка ответа с бинарными данными
        mockGetDocument.whenAnyExchangeReceived(exchange -> {
            exchange.getMessage().setBody("PDF content".getBytes());
            exchange.getMessage().setHeader(Exchange.CONTENT_TYPE, "application/pdf");
        });

        // Выполнение запроса
        Object response = producerTemplate.requestBodyAndHeaders(
            "direct:getDocumentRoute",
            null,
            Map.of(
                "packageId", "123",
                "documentId", "456"
            )
        );

        // Проверки
        mockGetDocument.assertIsSatisfied();
        assertTrue(response instanceof byte[]);
        assertEquals("PDF content", new String((byte[]) response));
    }
    
    @Test
    public void testRoute_ExceptionHandling() throws Exception {
        AdviceWith.adviceWith(camelContext, "direct:ru.seventech.esb.technoprom.createPackage.v2", a -> {
            a.weaveByToUri("https:*").replace().to("mock:https:external-service/createPackage");
        });
        
        camelContext.start();
        
        MockEndpoint mockCreatePackage = camelContext.getEndpoint(
            "mock:https:external-service/createPackage", MockEndpoint.class);
        
        // Эмуляция HTTP ошибки
        mockCreatePackage.whenAnyExchangeReceived(exchange -> {
            exchange.getMessage().setBody("""
                {
                    "error": "Invalid input",
                    "code": "400"
                }
                """);
            exchange.getMessage().setHeader(Exchange.HTTP_RESPONSE_CODE, 400);
        });

        // Выполнение запроса
        Exchange response = producerTemplate.request(
            "direct:ru.seventech.esb.technoprom.createPackage.v2", 
            exchange -> exchange.getIn().setBody("invalid-request")
        );

        // Проверки
        mockCreatePackage.assertIsSatisfied();
        assertEquals(400, response.getMessage().getHeader(Exchange.HTTP_RESPONSE_CODE));
        assertTrue(response.getMessage().getBody(String.class).contains("Invalid input"));
    }
}
