public Map<MultipartFile, List<MultipartFile>> mapFilesToSignatures(List<MultipartFile> files) {
    checkUniqueFilenames(files);
    Map<MultipartFile, List<MultipartFile>> result = new HashMap<>();
    Map<String, MultipartFile> fileByName = new HashMap<>();

    // Сначала собираем все файлы в мапу по именам
    for (MultipartFile file : files) {
        fileByName.put(file.getOriginalFilename(), file);
    }

    // Проверяем все сигнатурные файлы на валидность
    for (MultipartFile file : files) {
        String filename = file.getOriginalFilename();
        if (fileIsSignature(filename)) {
            validateSignatureFile(filename, fileByName);
        }
    }

    // Для каждого файла ищем его подписи
    for (MultipartFile file : files) {
        String filename = file.getOriginalFilename();
        if (fileIsSignature(filename)) {
            continue;
        }
        
        List<MultipartFile> signatures = new ArrayList<>();
        String baseSignatureName = filename + ".sig";
        String firstNumberedSignatureName = filename + ".1.sig";

        // Проверяем случай, когда есть и .sig и .1.sig - это ошибка
        if (fileByName.containsKey(baseSignatureName) {
            if (fileByName.containsKey(firstNumberedSignatureName)) {
                throw new IllegalArgumentException("For file " + filename + 
                    " both .sig and .1.sig signatures exist. Only one format is allowed.");
            }
            signatures.add(fileByName.get(baseSignatureName));
        } else {
            // Ищем нумерованные подписи
            int counter = 1;
            while (true) {
                String numberedSignatureName = filename + "." + counter + ".sig";
                if (fileByName.containsKey(numberedSignatureName)) {
                    signatures.add(fileByName.get(numberedSignatureName));
                    counter++;
                } else {
                    break;
                }
            }
        }

        if (!signatures.isEmpty()) {
            result.put(file, signatures);
        }
    }

    return result;
}

private void validateSignatureFile(String signatureFilename, Map<String, MultipartFile> fileByName) {
    // Проверяем, что сигнатурный файл не существует без основного файла
    String mainFilename = getMainFilenameFromSignature(signatureFilename);
    if (!fileByName.containsKey(mainFilename)) {
        throw new IllegalArgumentException("Signature file " + signatureFilename + 
            " has no corresponding main file");
    }

    // Проверяем, что если есть несколько сигнатур, то они нумерованные
    if (signatureFilename.endsWith(".sig") && !signatureFilename.endsWith(".1.sig")) {
        String firstNumberedSig = mainFilename + ".1.sig";
        if (fileByName.containsKey(firstNumberedSig)) {
            throw new IllegalArgumentException("Mixed signature formats for file " + mainFilename + 
                ". Cannot have both .sig and numbered signatures");
        }
    }
}

private String getMainFilenameFromSignature(String signatureFilename) {
    if (signatureFilename.endsWith(".sig")) {
        if (signatureFilename.matches(".*\\.\\d+\\.sig$")) {
            // Нумерованная сигнатура (например .1.sig, .2.sig)
            return signatureFilename.replaceFirst("\\.\\d+\\.sig$", "");
        } else {
            // Базовая сигнатура (.sig)
            return signatureFilename.replace(".sig", "");
        }
    }
    throw new IllegalArgumentException("Invalid signature filename: " + signatureFilename);
}

private boolean fileIsSignature(String filename) {
    return filename.endsWith(".sig");
}

private void checkUniqueFilenames(List<MultipartFile> files) {
    Set<String> filenames = new HashSet<>();
    for (MultipartFile file : files) {
        if (!filenames.add(file.getOriginalFilename())) {
            throw new IllegalArgumentException("Duplicate filename: " + file.getOriginalFilename());
        }
    }
}
